# [GOHW-4]: _System design_ телеграм бота по учёту расходов

## Функциональные требования (зачем нужен сервис, какую проблему он решает):

- Позволяет добавлять/редактировать/удалять финансовые траты, где каждая трата это следующий набор данных:
    - сумма
    - категория
    - дата (опционально со временем)
    - опциональный комментарий
- Позволяет получать отчёты по тратам по выбранным категориям на выбранный период
- Предоставляет возможность просматривать занесённые траты
- Позволяет выбрать валюту, которая будет использоваться для:
    - внесения траты
    - отчётов
    - списка трат
- Позволяет установить лимит общий лимит трат на текущий месяц

## Не функциональные требования:

- отказоустойчивость
- доступность
- высокая скорость работы
    - отзывчивость к сообщениям пользователя
    - быстрая генерация отчётов (асинхронно в случае большой нагрузки)
    - быстрое добавление траты и получение их списка

## Дополнительные требования:

- аналитика
- A/B тесты
- мониторинг системы
- сбор трейсов и логов
- обратная связь

# Входные данные

- Пользователь в день вносит в среднем по 5 трат
- Пользователь в день запрашивает по 2 отчёта
- Пользователь в день просматривает занесённые траты 3 раза
- У пользователя в среднем 20 различных категорий

Итого получается, что пользователь в среднем делает по 10 запросов к сервису.

## Нагрузка (средняя - максимальная = x3 от средней):

- для `1000` пользователей - `1000 * 10 / 24 / 60 ~= 7` RPS. max = **21 RPS**
- для `100 000` пользователей - **700-2100 RPS**
- для `1 000 000` пользователей - **7000-21000 RPS**

С увеличением нагрузки на каждую группу серверов будем добавлять балансировщик и
увеличивать количество активных серверов, а также тех, которые в запасе.


## Оценка хранилища:

Хранилище трат при больших объёмах будем шардировать по ID пользователя с использованием
консистентного хеширования.
При помощи сервера аналитики будем считать самых активных пользователей, тем
самым при старте нового экземпляра базы у нас будет возможность её "прогреть".

### Оценка размеров записи

Каждая трата представляет собой в среднем `8 + 8 + 64 + 8 + 128 = 216` байт, но округлим до `256`:

- идентификатор пользователя, кому принадлежит трата - **8 байт**
- сумма - **8 байт**
- категория - ограничим в **256 байт**, в среднем будем считать, что занимает **64 байта**
- дата - timestamp, то есть **8 байт**
- комментарий - опциональное поле, ограничим в **2048 байт**, в среднем будет занимать **128 байт**

Каждый пользователь (с его настройками) представляет собой в среднем `8 + 8 + 8 = 24` байт, но округлим до `32`:

- идентификатор пользователя - **8 байт**
- код валюты - **8 байт**
- месячный лимит трат - **8 байт**

Каждая запись о курсе представляет собой в среднем `8 + 8 + 8 = 24` байт, но округлим до `32`:

- код валюты - **8 байт**
- обменный курс по отношению к базовой валюте - **8 байт**
- дата - timestamp - **8 байт**

### Оценка размеров хранимых данных в соответствии с разделом выше

Пользователь в среднем вносит 5 трат. Соотв. по тратам в год (усредним в 365 дней) это 1825 записей (используем
округлённые значения).

- для `1000` пользователей в год - `1 825 000` записей = **467.2 Мегабайт**
- для `100 000` пользователей в год - `182 500 000` записей = **46.72 Гигабайт**
- для `1 000 000` пользователей в год - `1 825 000 000` записей = **467.2 Гигабайт**

Данные о курсах будут обновляться, а также запрашиваться по мере необходимости.
Они будут занимать крайне мало места, как и данные о пользователях.
Поэтому опустим вычисления, связанные с ними.

Также заложим место под бекап, соответственно это как минимум x3 к размеру хранимых данных.
Ещё учтём реплики, это также x2-x3 к размеру хранимых данных.
Итого выходит, что хранить придётся x5-x6 от размера исходных данных.

## Оценка размера оперативной памяти:

В оперативной памяти будут лежать данные, которые либо меняются редко, либо нужны очень часто и быстро.
Это шаблоны, курсы валют и пользовательские настройки. 
Точный расчёт приведён не будет, так как эти данные в текущей схеме 
укладываются в размер **2 Гигабайта** с большим запасом.

Более интересно дела обстоят с тратами и отчётами по ним. 
Пользователи обычно не просматривают траты как объекты, а просматривают статистику по ним, то есть отчёты.
Самое популярное это за последние день, месяц (и его друге дни) и год.

Условимся, что в месяце по 30 дней. Пользователь вносит траты по категориям (которых условно 20 в среднем), 
соответственно для каждой категории будет свой отчёт для каждого пользователя.
Тогда получается, что при добавлении траты необходимо обновить следующие 3 записи в кеше:
- отчёт за последний день по категории
- отчёт за последний месяц по категории
- отчёт за последний год по категории

То есть всего на пользователя в кеше будет храниться в максимуме 32 записи. 

Сам отчёт будет представлять собой пару значений в сумме дающих **72 байта**:
- категория - условно округлили до **64 байт**
- сумма - возьмём **8 байт**

Округлим до **128 байт**, так как в кеше ещё часть памяти будет тратиться под
ключи для данных записей.
Итого, получается, что:
- для `1000` пользователей - `128 * 32 * 20 * 1000` = **81.92 Мегабайт**
- для `100 000` пользователей - **8.192 Гигабайт**
- для `1 000 000` пользователей - **81.92 Гигабайт**

То есть, `82 + 2` = **84 Гигабайта** придётся хранить в памяти суммарно.
Стоит заметить, что это максимальные показатели.

Однако, закладываться на такой объём памяти нет необходимости, так как:
- не все пользователи будут очень активными
- не каждый пользователь будет запрашивать столько данных, на сколько мы заложились
- обновлять данные пользователя в кеше при их изменении кажется излишним,
поскольку, к примеру, при добавлении пользователем 100 трат мы будем 100 раз
рассчитывать показатели заново, что избыточно

Поэтому нет необходимости хранить столько данных и рассчитывать всё наперёд.
Достаточно инвалидировать кеш по пользователю при изменении данных и только 
в случае запроса отчёта загружать данные в кеш. В случае нехватки места в кеше
устаревшие данные будут вымещаться.

Заложим размер кеша в 20-25% от максимального возможного объёма (который выше), а
при добавлении новой траты будем инвалидировать существующий кеш. 
Как итог, будет достаточно **20 Гигабайт** для кеша при `1 000 000` пользователей. 
Для меньшего/большего количества пользователей объём будет зависеть пропорционально.
